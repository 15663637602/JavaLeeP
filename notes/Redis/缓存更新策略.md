|      |内存淘汰|超时剔除|主动更新|
|--------|----|----|----|
|说明   |不用维护，利用redis内存淘汰机制，当内存不足时自动淘汰数据，下次查询时更新|添加TTL，到期自动删除缓存|编写业务逻辑，在修改数据库的同时，更新缓存|
|一致性  |差|一般|好|
|维护成本|无|低|高|

### 缓存更新策略
低一致性需求：使用redis自带的内存淘汰机制
高一致性需求：主动更新，并以超时剔除作为兜底

### 主动更新
1. Cache Aside Pattern 有缓存的调用者，在更新数据库的同时更新缓存（人工编码）
2. Read/Write Through Pattern 将缓存和数据库整合成一个服务，调用者无需关心缓存一致性问题。（服务开发成本很高）
3. Write Behind Caching Pattern 同样为了减轻调用者工作量。调用者只操作缓存，由其他线程异步的将数据持久化到数据库，保证**最终一致**
> 一般都是采用第一种方法。

### Cache Aside Pattern
1. 删除缓存还是更新缓存？
> 更新缓存：每次更新数据库都更新缓存，**无效写操作较多**
> **删除缓存**：更优，更新数据库时让缓存失效，查询时再更新缓存
2. 如何保证缓存与数据库的操作的同时成功或失败
> 单体系统，利用事务
> 分布式系统，利用TCC等分布式事务方案
3. 多线程并发的情况下，是先操作缓存还是操作数据库？
> 先操作数据库，再删除缓存 更优

#### 先删除缓存，再操作数据库
> 操作redis速度往往比数据库快很多，所以导致缓存和数据库数据不一致的概率较高

在并发情况下，会发生异常情况（以下依次为发生顺序）：
process1-step1: 删除缓存（很快）
process2-step1: 查询缓存，未命中，查询数据库
process2-step2: 将旧数据写入缓存
process1-step1: 更新数据库中的数据
#### 先操作数据库，再删除缓存
> 发生的概率较低

异常情况（以下依次为发生顺序）：
init: 由于某些原因，redis缓存数据失效了
process1-step1: 查询缓存，未命中，查询数据库，查到旧数据，**准备**将旧数据写入redis。
process2-step1: 更新数据库为新的值
process2-step2: 删除缓存数据
process1-step2: 写入了旧数据



