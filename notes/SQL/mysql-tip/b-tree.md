### 索引 是帮助Mysql可以高效获取数据的  [排好序] 的 [数据结构](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

#### 索引的数据结构有：
- 二叉树：最坏的情况下会变成链表
- 红黑树：树的高度不可控，当数据量很大时，树的高度太高了
- hash表：无法排序
- b-tree：是一种平衡的**多路查找树**，多路查找，多路查找，多路查找。B树就是B-树，"-"是个连字符号，不是减号。

#### [b树]((https://zhuanlan.zhihu.com/p/146252512))
>  B-树的主要目的就是减少磁盘的 I/O 操作，(树中 每一次查找到叶子结点，都是一次IO操作。)
>  B-树的每个节点可以有多个关键字，所以可以进行多路分支选择，而不像二叉树，只能做二路分支选择。

大多数平衡树的操作（查找、插入、删除，最大值、最小值等等）需要**O(H)次**磁盘访问操作，其中**H**是树的高度。但是对于B-树而言，树的**高度将不再是logN**(其中**N**是树中的结点个数），而是一个我们**可控的高度**（通过调整 B-树中结点所包含的键【你也可以叫做数据库中的索引，本质上就是在磁盘上的一个位置信息】的数目，使得 B-树的高度保持一个较小的值）。一般而言，B-树的结点所包含的键的数目和磁盘块大小一样，从数个到数千个不等。由于**B-树的高度 h 可控（一般远小于logN）**，所以与 AVL 树和红黑树相比，B-树的磁盘访问时间将极大地降低。

1. **所有的叶子结点都出现在同一层上，并且不带信息**(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。
2. **每个结点包含的关键字**个数有**上界和下界**。用一个被称为 B-树的 **最小度数** 的固定整数t >= 2来表示这些界 ，其中t取决于磁盘块的大小：
a. 除根结点以外的每个结点必须至少有t-1个关键字。因此，除了根结点以外的每个内部结点有 t 个孩子。如果树非空，根结点至少有一个关键字。
b. 每个结点至多包含2t-1个关键字。
3. **一个包含x个关键字的结点有x+1个孩子**，如下图；
4. 一个结点中的所有关键字升序排列，两个关键字k1和k2之间的孩子结点的所有关键字 key 在  的范围之内。
5. 与二叉排序树不同， B-树的搜索是从根结点开始，**根据结点的孩子树做多路分支选择**，而**二叉排序树**做的是**二路分支选择，每一次判断都会进行一次磁盘 I/O操作。**
6. 与其他平很二叉树类似，**B-树查找、插入和删除操作的时间复杂度为O(logN)量级。**
![v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp](https://pic1.zhimg.com/80/v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp)
上图就是一颗典型的 B-树，其中最小度数t=2，根结点至少包含一个关键字 P ，根结点以外的每个结点至少有 t - 1 = 1 个，每个结点最多包含 2t - 1= 3 个关键字；包含三个 1 关键字 P 的根结点有 1 + 1 = 2 个孩子结点，包含 3 个关键字的结点 (C、G、L) 包含有 4 个孩子。同一个结点中的所有关键字升序排列，比如结点 (D、E、F) 的内部结点就是升序排列，且均位于其父结点中的关键字 C 和 G 之间。所有的叶结点均为空。

#### b树的查找
> B-树的查找操作与二叉排序树（BST）极为类似，只不多 B-树中的每个结点包含多个关键字。假设待查找的关键字为 k ，我们从根结点开始，递归向下进行查找。对每一个访问的非叶子结点，如果结点包含待查找的关键字 k ，则返回结点指针；否则，我们递归到该结点的恰当子代（该子代结点中的关键字均在比 k 更大的关键字之前）。如果抵达了叶子结点且没有找到 k 则返回 null .

![v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp](https://pic1.zhimg.com/80/v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp)
我们以查找关键字 F 为例进行说明。

第一步：访问根结点 P ，发现关键字 F 小于 P ，则查找结点 P 的左孩子。
![v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp](https://pic2.zhimg.com/80/v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp)

第二步：访问结点 P 的左子结点 [C、G、L] ，**对于一个结点中包含多个关键字时，顺序进行访问**，首先与关键字 C 进行比较，**发现比 C 大**；然后与关键字 G 进行比较，发现**比 G 小**，则**说明**待查找**关键字 F 位于关键字 C 和关键字 G 之间的子代中**。
![v2-9d1cdf2a18171a316c43711d26e8835c_720w.webp](https://pic1.zhimg.com/80/v2-9d1cdf2a18171a316c43711d26e8835c_720w.webp)

第三步：访问关键字 C 和关键字 G 之间的子代，该子代结点包含三个关键字 [D、E、F] ，进行顺序遍历，比较关键字 D 和 F ，F 比 D 大
![v2-2e3dc3c438285b97ae28b117df1c3032_720w.webp](https://pic3.zhimg.com/80/v2-2e3dc3c438285b97ae28b117df1c3032_720w.webp)

顺序访问关键字 E ，F 比 E 大：
![v2-a91112d7e1a2d9b803aa1f1792636efe_720w.webp](https://pic3.zhimg.com/80/v2-a91112d7e1a2d9b803aa1f1792636efe_720w.webp)

顺序访问关键字 F ，发现与待查找关键字相同，查找成功。则返回结点 [D、E、F] 的指针。
![v2-3a2adcbaa6bd03e4011cac5542fa8bd9_720w.webp](https://pic2.zhimg.com/80/v2-3a2adcbaa6bd03e4011cac5542fa8bd9_720w.webp)

#### b树的插入
> 一个新插入的关键字 k 总是被插入到叶子结点。与二叉排序树的插入操作类似，我们从根结点开始，向下遍历直到叶子结点，到达叶子结点，将关键字 k 插入到相应的叶子结点。与 BST 不同的是，我们通过最小度定义了一个结点可以包含关键字的个数的一个取值范围，所以在插入一个关键字时，就需要确认插入关键字之后  **结点是否超出结点本身最大可容纳的关键字个数**。
> 事实上 B-树的插入操作是一种 **主动插入** 算法，因为**在插入新的关键字  之前**，我们会**将所有已满的结点进行拆分**，**提前拆分的好处就是，我们不必进行回溯，遍历结点两次**。如果我们不事先拆分一个已满的结点，而仅仅在插入新的关键字时才拆分它，那么最终可能需要再次从根结点出发遍历所有结点，比如在我们到达叶子结点时，**将叶结点进行拆分，并将其中的一个关键字上移导致父结点分裂**（因为上移导致父结点超出可存储的关键字的个数），父结点的分裂后，新的关键字继续上移，将可能导致新的父结点分裂，从而出现大量的回溯操作。但是 B-树这种主动插入算法中，就不会发生级联效应。当然，这种**主动插入的缺点也很明显，我们可能进行很多不必要的拆分操作。**
以在上图中插入关键字 I 为例进行说明。其中最小度 t = 2 ，一个结点最多可存储 2t - 1 = 3 个结点。

第一步：访问根结点，发现插入关键字 I 小于 P , 但**根结点未满，不分裂**，直接访问其第一个孩子结点。
![v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp](https://pic2.zhimg.com/80/v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp)

第二步：访问结点 P 的第一个孩子结点 [C、G、L] ，发现第一个孩子结点已满，将第一个孩子结点分裂为两个，将G上移。这里就是**提前拆**：
![v2-1fabc4c8f43521be40d2522917a6288f_720w.webp](https://pic4.zhimg.com/80/v2-1fabc4c8f43521be40d2522917a6288f_720w.webp)

第三步：将结点 I 插入到结点 L 的第一个左孩子当中，发现 L 的第一个左孩子 [H、J、K] 已满，则将其分裂为两个。
![v2-4116492cec43d1220a0dd028c0ee77c5_720w.webp](https://pic2.zhimg.com/80/v2-4116492cec43d1220a0dd028c0ee77c5_720w.webp)

第四步：将结点 I 插入到结点 J 的第一个孩子当中，发现 L 的第一个孩子结点 [H] 未满且为叶子结点，则将 I 直接插入。
![v2-1d2306fcc41ff04104c4f573cf679c05_720w.webp](https://pic2.zhimg.com/80/v2-1d2306fcc41ff04104c4f573cf679c05_720w.webp)


