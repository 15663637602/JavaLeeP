### 索引 是帮助Mysql可以高效获取数据的  [排好序] 的 [数据结构](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

#### 索引的数据结构有：
- 二叉树：最坏的情况下会变成链表
- 红黑树：树的高度不可控，当数据量很大时，树的高度太高了
- hash表：无法排序
- b-tree：是一种平衡的**多路查找树**，多路查找，多路查找，多路查找。B树就是B-树，"-"是个连字符号，不是减号。

#### [b树]((https://zhuanlan.zhihu.com/p/146252512))
>  B-树的主要目的就是减少磁盘的 I/O 操作，(树中 每一次查找到叶子结点，都是一次IO操作。)
>  B-树的每个节点可以有多个关键字，所以可以进行多路分支选择，而不像二叉树，只能做二路分支选择。

大多数平衡树的操作（查找、插入、删除，最大值、最小值等等）需要**O(H)次**磁盘访问操作，其中**H**是树的高度。但是对于B-树而言，树的**高度将不再是logN**(其中**N**是树中的结点个数），而是一个我们**可控的高度**（通过调整 B-树中结点所包含的键【你也可以叫做数据库中的索引，本质上就是在磁盘上的一个位置信息】的数目，使得 B-树的高度保持一个较小的值）。一般而言，B-树的结点所包含的键的数目和磁盘块大小一样，从数个到数千个不等。由于**B-树的高度 h 可控（一般远小于logN）**，所以与 AVL 树和红黑树相比，B-树的磁盘访问时间将极大地降低。

1. **所有的叶子结点都出现在同一层上，并且不带信息**(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。
2. **每个结点包含的关键字**个数有**上界和下界**。用一个被称为 B-树的 **最小度数** 的固定整数t >= 2来表示这些界 ，其中t取决于磁盘块的大小：
a. 除根结点以外的每个结点必须至少有t-1个关键字。因此，除了根结点以外的每个内部结点有 t 个孩子。如果树非空，根结点至少有一个关键字。
b. 每个结点至多包含2t-1个关键字。
3. **一个包含x个关键字的结点有x+1个孩子**，如下图；
4. 一个结点中的所有关键字升序排列，两个关键字k1和k2之间的孩子结点的所有关键字 key 在  的范围之内。
5. 与二叉排序树不同， B-树的搜索是从根结点开始，**根据结点的孩子树做多路分支选择**，而**二叉排序树**做的是**二路分支选择，每一次判断都会进行一次磁盘 I/O操作。**
6. 与其他平很二叉树类似，**B-树查找、插入和删除操作的时间复杂度为O(logN)量级。**
![v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp](https://pic1.zhimg.com/80/v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp)
上图就是一颗典型的 B-树，其中最小度数t=2，根结点至少包含一个关键字 P ，根结点以外的每个结点至少有 t - 1 = 1 个，每个结点最多包含 2t - 1= 3 个关键字；包含三个 1 关键字 P 的根结点有 1 + 1 = 2 个孩子结点，包含 3 个关键字的结点 (C、G、L) 包含有 4 个孩子。同一个结点中的所有关键字升序排列，比如结点 (D、E、F) 的内部结点就是升序排列，且均位于其父结点中的关键字 C 和 G 之间。所有的叶结点均为空。

#### b树的查找
> B-树的查找操作与二叉排序树（BST）极为类似，只不多 B-树中的每个结点包含多个关键字。假设待查找的关键字为 k ，我们从根结点开始，递归向下进行查找。对每一个访问的非叶子结点，如果结点包含待查找的关键字 k ，则返回结点指针；否则，我们递归到该结点的恰当子代（该子代结点中的关键字均在比 k 更大的关键字之前）。如果抵达了叶子结点且没有找到 k 则返回 null .

![v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp](https://pic1.zhimg.com/80/v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp)
我们以查找关键字 F 为例进行说明。

第一步：访问根结点 P ，发现关键字 F 小于 P ，则查找结点 P 的左孩子。
![v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp](https://pic2.zhimg.com/80/v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp)

第二步：访问结点 P 的左子结点 [C、G、L] ，**对于一个结点中包含多个关键字时，顺序进行访问**，首先与关键字 C 进行比较，**发现比 C 大**；然后与关键字 G 进行比较，发现**比 G 小**，则**说明**待查找**关键字 F 位于关键字 C 和关键字 G 之间的子代中**。
![v2-9d1cdf2a18171a316c43711d26e8835c_720w.webp](https://pic1.zhimg.com/80/v2-9d1cdf2a18171a316c43711d26e8835c_720w.webp)

第三步：访问关键字 C 和关键字 G 之间的子代，该子代结点包含三个关键字 [D、E、F] ，进行顺序遍历，比较关键字 D 和 F ，F 比 D 大
![v2-2e3dc3c438285b97ae28b117df1c3032_720w.webp](https://pic3.zhimg.com/80/v2-2e3dc3c438285b97ae28b117df1c3032_720w.webp)

顺序访问关键字 E ，F 比 E 大：
![v2-a91112d7e1a2d9b803aa1f1792636efe_720w.webp](https://pic3.zhimg.com/80/v2-a91112d7e1a2d9b803aa1f1792636efe_720w.webp)

顺序访问关键字 F ，发现与待查找关键字相同，查找成功。则返回结点 [D、E、F] 的指针。
![v2-3a2adcbaa6bd03e4011cac5542fa8bd9_720w.webp](https://pic2.zhimg.com/80/v2-3a2adcbaa6bd03e4011cac5542fa8bd9_720w.webp)

#### b树的插入
> 一个新插入的关键字 k 总是被插入到叶子结点。与二叉排序树的插入操作类似，我们从根结点开始，向下遍历直到叶子结点，到达叶子结点，将关键字 k 插入到相应的叶子结点。与 BST 不同的是，我们通过最小度定义了一个结点可以包含关键字的个数的一个取值范围，所以在插入一个关键字时，就需要确认插入关键字之后  **结点是否超出结点本身最大可容纳的关键字个数**。
> 事实上 B-树的插入操作是一种 **主动插入** 算法，因为**在插入新的关键字  之前**，我们会**将所有已满的结点进行拆分**，**提前拆分的好处就是，我们不必进行回溯，遍历结点两次**。如果我们不事先拆分一个已满的结点，而仅仅在插入新的关键字时才拆分它，那么最终可能需要再次从根结点出发遍历所有结点，比如在我们到达叶子结点时，**将叶结点进行拆分，并将其中的一个关键字上移导致父结点分裂**（因为上移导致父结点超出可存储的关键字的个数），父结点的分裂后，新的关键字继续上移，将可能导致新的父结点分裂，从而出现大量的回溯操作。但是 B-树这种主动插入算法中，就不会发生级联效应。当然，这种**主动插入的缺点也很明显，我们可能进行很多不必要的拆分操作。**
以在上图中插入关键字 I 为例进行说明。其中最小度 t = 2 ，一个结点最多可存储 2t - 1 = 3 个结点。

第一步：访问根结点，发现插入关键字 I 小于 P , 但**根结点未满，不分裂**，直接访问其第一个孩子结点。
![v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp](https://pic2.zhimg.com/80/v2-1cd9a41b609b3c2b20525463cd9dba65_720w.webp)

第二步：访问结点 P 的第一个孩子结点 [C、G、L] ，发现第一个孩子结点已满，将第一个孩子结点分裂为两个，将G上移。这里就是**提前拆**：
![v2-1fabc4c8f43521be40d2522917a6288f_720w.webp](https://pic4.zhimg.com/80/v2-1fabc4c8f43521be40d2522917a6288f_720w.webp)

第三步：将结点 I 插入到结点 L 的第一个左孩子当中，发现 L 的第一个左孩子 [H、J、K] 已满，则将其分裂为两个。
![v2-4116492cec43d1220a0dd028c0ee77c5_720w.webp](https://pic2.zhimg.com/80/v2-4116492cec43d1220a0dd028c0ee77c5_720w.webp)

第四步：将结点 I 插入到结点 J 的第一个孩子当中，发现 L 的第一个孩子结点 [H] 未满且为叶子结点，则将 I 直接插入。
![v2-1d2306fcc41ff04104c4f573cf679c05_720w.webp](https://pic2.zhimg.com/80/v2-1d2306fcc41ff04104c4f573cf679c05_720w.webp)

#### b树的删除
> B-树的删除操作相比于插入操作更为复杂，如果仅仅只是删除叶子结点中的关键字，也非常简单，但是**如果删除的是内部节点的，就不得不对结点的孩子进行重新排列**。
> 与 B-树的插入操作类似，我们必须确保删除操作不违背 B-树的特性。正如插入操作中每一个结点所包含的关键字的个数不能超过 2t -1 一样，删除操作要保证每一个结点包含的关键字的个数不少于 t -1 个（除根结点允许包含比 t -1 少的关键字的个数。

初始的 B-树 如图所示，其中最小度 t = 3 每一个结点最多可包含 5 个关键字，至少包含 2个关键字（根结点除外）。
![v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp](https://pic1.zhimg.com/80/v2-b715e3c92bc89bdd3122af36dd0f3764_720w.webp)

**情况1. 待删除的关键字 k 在结点 x 中，且 x 是叶子结点，删除关键字k
例如删除 F**
![v2-ea8a5571d3c316454f5a6f4d26010095_720w.webp](https://pic2.zhimg.com/80/v2-ea8a5571d3c316454f5a6f4d26010095_720w.webp)

**情况2. 待删除的关键字 k 在结点 x 中，且 x 是内部结点，细分成三种情况**
**A: 如果位于结点 x 中的关键字 k 之前的第一个孩子结点 y 至少有 t 个关键字，则在孩子结点 y 中找到 k 的前驱结点k0，递归地删除关键字k0，并将结点 x 中的关键字 k 替换为k0.**
删除 B-树中的关键字 G ，G 的前一个孩子结点 y 为 [D、E、F] ，包含 3个关键字，满足情况一，关键字 G 的直接前驱为关键 F ，删除 F ，然后将 G 替换为 F .
![v2-6869859fe08f4d9f4bd89f4c386107e2_720w.webp](https://pic3.zhimg.com/80/v2-6869859fe08f4d9f4bd89f4c386107e2_720w.webp)
**B: y 所包含的关键字少于 t 个关键字，则检查结点 x 中关键字 k 的后一个孩子结点 z 包含的关键字的个数，如果 z 包含的关键字的个数至少为 t 个，则在 z 中找到关键字 k 的直接后继  ,然后删除  ，并将关键 k 替换为  .**
删除 B-树中的关键字 C , y 中包含的关键字的个数为 2 个，小于 t = 3 ,结点 [C、G、L] 中的 关键字 C 的后一个孩子 z 为 [D、E、F] 包含 3 个关键字，关键字 C 的直接后继为 D ，删除 D ，然后将 C 替换为 D .
![v2-e8fb5703f6b561669e9863335767f550_720w.webp](https://pic1.zhimg.com/80/v2-e8fb5703f6b561669e9863335767f550_720w.webp)
**C: 如果 y 和 z 都只包含 t -1 个关键字，合并关键字 k 和所有 z 中的关键字到 结点 y 中，结点 x 将失去关键字 k 和孩子结点 z，y 此时包含 2t -1 个关键字，释放结点 z 的空间并递归地从结点 y 中删除关键字 k.**
![v2-d001f956d029914d9704f13d43da6043_720w.webp](https://pic4.zhimg.com/80/v2-d001f956d029914d9704f13d43da6043_720w.webp)
删除关键字 C , 结点 y 包含 2 个关键字 ，结点 z 包含 2 个关键字，均等于 t - 1 = 2 个， 合并关键字 C 和结点 z 中的所有关键字到结点 y 当中：
![v2-b3bba31adeb70f918d01889c2748d1ce_720w.webp](https://pic3.zhimg.com/80/v2-b3bba31adeb70f918d01889c2748d1ce_720w.webp)

此时结点 y 为叶子结点，直接删除关键字 C
![v2-f40d4968bd5f9714a15c5928758170eb_720w.webp](https://pic4.zhimg.com/80/v2-f40d4968bd5f9714a15c5928758170eb_720w.webp)

**情况3: 如果关键字 k 不在当前在内部结点 x 中，则确定必包含 k 的子树的根结点 x.c(i) （如果 k 确实在 B-树中）。如果 x.c(i) 只有 t - 1 个关键字，必须执行下面两种情况进行处理：**
首先我们得确认什么是当前内部结点 x ，什么是 x.c(i) ,如下图所示， P 现在不是根结点，而是完整 B-树的一个子树的根结点：
![v2-d7fdffa5f9ee6d4ee68bfc903bc277a4_720w.webp](https://pic1.zhimg.com/80/v2-d7fdffa5f9ee6d4ee68bfc903bc277a4_720w.webp)
**A：如果 x.c(i) 及 x.c(i) 的所有相邻兄弟都只包含 t - 1 个关键字，则将 x.c(i) 与 一个兄弟合并，即将 x 的一个关键字移动至新合并的结点，使之成为该结点的中间关键字，将合并后的结点作为新的 x 结点 .**
上面的图标明了相应的 x 及 x.c(i) ，我们以删除关键字 D 为例，此时当前内部结点 x 不包含关键字 D , 确定是第三种情况，我们可以确认关键 D 一定在结点 x 的第一个孩子结点所在的子树中，结点 x 的第一个孩子结点所在子树的跟结点为 x.c(i) 即 [G、L] . 其中 结点 [G、L] 及其相邻的兄弟结点 [T、W] 都只包含 2 个结点（即 t - 1) ，则将 [G、L] 与 [T、W] 合并，并将结点 x 当中仅有的关键字 P 合并到新结点中；然后将合并后的结点作为新的 x 结点，递归删除关键字 D ，发现D 此时在叶子结点 y 中，直接删除，就是 1. 的情况。
![v2-bb7979695fbee22866d34788564cfa7f_720w.webp](https://pic4.zhimg.com/80/v2-bb7979695fbee22866d34788564cfa7f_720w.webp)
**B: x.c(i) 仅包含 t - 1 个关键字且 x.c(i) 的一个兄弟结点包含至少 t 个关键字，则将 x 的某一个关键字下移到 x.c(i) 中，将 x.c(i) 的相邻的左兄弟或右兄弟结点中的一个关键字上移到 x 当中，将该兄弟结点中相应的孩子指针移到 x.c(i) 中，使得 x.c(i) 增加一个额外的关键字。**
在上面情况删除后的结果上继续进行说明：
![v2-52091a310432b930555708a7de84eb31_720w.webp](https://pic2.zhimg.com/80/v2-52091a310432b930555708a7de84eb31_720w.webp)
我们以删除结点 [A、B] 中的结点 B 为例，上图中 x.c(i) 包含 2 个关键字，即 t - 1 个关键字， x.c(i) 的一个兄弟结点 [H、J、K] 包含 3 个关键字（满足至少 t 个关键字的要求），则将兄弟结点 [H、J、K] 中的关键字 H 向上移动到 x 中， 将 x 中的关键字 C 下移到 x.c(i) 中；删除关键字 B .
![v2-b9bedb83931296ac8e2f67aee76654c1_720w.webp](https://pic2.zhimg.com/80/v2-b9bedb83931296ac8e2f67aee76654c1_720w.webp)

