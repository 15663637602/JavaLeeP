mysql innodb的删除是先标记，然后异步线程去做删除，在这个过程中会产生不少内存碎片，所以定期optimize table可以提升性能。

从 MySQL 5.6 版本开始，
- alter table t engine = InnoDB（也就是 recreate）
- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；
- optimize table t 等于 recreate + analyze。


在 InnoDB 中，你的 delete 操作，并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记，标记为删除，因此你使用 delete 删除表中的数据，表文件在磁盘上所占空间不会变小。

delete 操作并没有真正删除数据，表的空间并没有被释放。这些被删除的记录行，只是被标记删除，是可以被复用的，下次有符合条件的记录是可以直接插入到这个被标记的位置的。

比如我们在 id 为 300-600 之间的记录中删除一条 id=500 的记录，这条记录就会被标记为删除，等下一次如果有一条 id=400 的记录要插入进来，那么就可以复用 id=500 被标记删除的位置，这种情况叫行记录复用。还有一种情况是数据页复用，就是指整个数据页都被标记删除了，于是这整个数据页都可以被复用了，和行记录复用不同的是，数据页复用对要插入的数据几乎没有条件限制。

还以上面那个插入为例，**假如要插入的记录是 id=1000，那么就不能复用 id=500 这个位置了，一般主键是自增id，几乎不会被复用**。但如果有一整个数据页可复用的话，那么无论 id 值为多少都可以被复用在这个页上。

这些被标记删除的记录，其实就是一个空洞，有种占着茅坑不拉屎的感觉，浪费空间不说，还**会影响查询效率**。因为你要知道，mysql 在底层是以数据页为单位来存储和读取数据的，每次向磁盘读一次数据就是读一个数据页，然而每访问一个数据页就对应一次磁盘 IO 操作，磁盘 IO 相对内存访问速度是相当慢的。



如果一个表上存在大量的数据空洞，原本只需一个数据页就保存的数据，由于被很多空洞占用了空间，不得不需要增加其他的数据页来保存数据，相应的，mysql 在查询相同数据的时候，就不得不增加磁盘 IO 操作，从而影响查询速度。**其实不仅仅是删除操作会造成数据空洞，插入和更新同样也会造成空洞**。因此，一个数据表在经过大量频繁的增删改之后，难免会产生数据空洞，浪费空间并影响查询效率，通常在生产环境中会直接表现为原本很快的查询会变得越来越慢。对于这种情况，我们通常可以使用下面这个命令就能解决数据空洞问题。
```
optimize table t
```
这个命令的原理就是重建表，就是建立一个临时表 B，然后把表 A（存在数据空洞的表） 中的所有数据查询出来，接着把数据全部重新插入到临时表 B 中，最后再用临时表 B 替换表 A 即可，这就是重建表的过程。

另外下面这个命令也可以实现重建表，可以达到跟上面一样的效果，而且推荐使用下面这个命令
```
alter table t engine=InnoDB
```
### 计算碎片大小
可以通过show table [from|in db_name] status like '%table_name%'命令查看：
```
mysql> show table from employees status like 't1'\G
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 1176484
 Avg_row_length: 86
    Data_length: 101842944
Max_data_length: 0
   Index_length: 0
      Data_free: 39845888
 Auto_increment: NULL
    Create_time: 2018-08-28 13:40:19
    Update_time: 2018-08-28 13:50:43
     Check_time: NULL
      Collation: utf8mb4_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)

```
碎片大小 = 数据总大小 - 实际表空间文件大小
**data_length - avg_row_length * rows**

### 重建表
1.建一张结构一样的临时表，把表内的数据导入到临时表，直接删除旧表，然后将临时表替换为旧表，完成重建。
2.通过alter table tableName engine=innodb 命令来重建表。在MySQL5.5版本之前，这个命令的执行流程跟1操作差不多，区别只是在于这个临时表不需要你直接创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。
显然，花时间最多的步骤是往临时表插入数据的过程，**如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，旧表中不能有更新。也就是说，这个 DDL 不是 Online 的(在MySQL5.5版本之前)**。

而在MySQL5.6版本开始引入的Online DDL，对这个操作流程做了优化：
1. 建立一个临时文件，扫描表A主键的所有数据页；
2. 用数据页中表A的记录生产B+树，存储到临时文件中；
3. 生产临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中；
4. **临时文件生成后，将日志文件中的操作应用到临时文件**，得到一个逻辑数据上与表A相同的数据文件；
5. 用临时文件替换表A的数据文件。

**执行alter语句时，需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁。**
为了实现Online，**MDL读锁不会阻塞增删改操作**。
那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。
