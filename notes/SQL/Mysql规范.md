### (一) 建表规约
1. 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）。 说明：任何字段如果为非负数，必须是unsigned。 正例： 表达逻辑删除的字段名 is_deleted 1 表示删除， 0 表示未删除。
2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明： MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库
名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。
正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name
3. 【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。
4. 【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。
5. 【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。 说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。
6. 【强制】小数类型为decimal，禁止使用float和double。 说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。
7. 【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。
8. 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
9. 【强制】表必备三字段：**id, gmt_create, gmt_modified**。 说明： 其中 id必为主键，类型为 unsigned bigint、单表时自增、步长为 1 。 gmt_create, gmt_modified的类型均为 date_time类型，前者现在时表示主动创建，后者过去分词表示被动更新。
10. 【推荐】表的命名最好是加上“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config
11. 【推荐】库名与应用名称尽量一致。
12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
13. 【推荐】**字段允许适当冗余**，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 1）不是频繁修改的字段。 2）不是varchar超长字段，更不能是text字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。
14. 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。
15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 **无符号值可以避免误存负数，且扩大了表示范围**。


### (二) 索引规约
1. 【强制】**业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引**。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，**只要没有唯一索引，根据墨菲定律，必然有脏数据产生**。
2. 【强制】**超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表join也要注意表索引、SQL性能**。
3. 【强制】**在varchar字段上建立索引时，必须指定索引长度**，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，**可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定**。
4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
5. 【推荐】如果有order by的场景，请注意利用索引的有序性。order by **最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况**，影响查询性能。 
> 正例：where a=? and b=? order by c; 索引：a_b_c 
> 反例：**索引中有范围查找，那么索引有序性无法利用**，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。
6. 【推荐】利用覆盖索引来进行查询操作，避免回表。 说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using index。
7. 【推荐】利用延迟关联或者子查询**优化超多分页场景**。 说明：**MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下**，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 
> 正例：**先快速定位需要获取的id段，然后再关联**： **SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id**
8. 【推荐】 SQL性能优化的目标：**至少要达到 range 级别，要求是ref级别，如果可以是consts最好**。 说明： 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。
9. 【推荐】建组合索引的时候，区分度最高的在最左边。 正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。 说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。
10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。
11. 【参考】创建索引时避免有如下极端误解： 1）宁滥勿缺。认为一个查询就需要建一个索引。 2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

#### 哪些情况适合创建索引
	1. 字段的数值有唯一性的限制
	2. 频繁作为 WHERE 查询条件的字段
	3. 经常 GROUP BY 和 ORDER BY 的列
	4. UPDATE、DELETE的WHERE条件列
	5. DISTINCT的字段
	6. 对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致
	7. 使用列的类型小的创建索引：比如我们能使用INT就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用 INT。数据类型越小，在查询时进行的比较操作越快；数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。
	8. 区分度高(散列性高)的列适合作为索引：列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是3，最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好，SELECT COUNT(DISTINCT 列名) / COUNT(*) FROM 表名;越接近1越好，一般超过33%就算是比较高效的索引了。
	9. 联合索引把区分度高(散列性高)的列放在前面。
	10. 使用最频繁的列放到联合索引的左侧
	11. 在多个字段都要创建索引的情况下，联合索引优于单值索引

#### 限制索引的数目
建议单张表索引数量不超过6个。原因:
1：每个索引都需要占用 磁盘空间，索引越多，需要的磁盘空间就越大。
2：索引会影响 INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
3：优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。

#### 哪些情况不适合创建索引
	1. WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引
	2. 数据量小的表，比如少于 1000 个，最好不要使用索引
	3. 有大量重复数据的列上不要建立索引
示例：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。
索引的价值是帮你快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值，比如通常情况下的性别字段。
结论：当数据重复度大，比如 高于10% 的时候，也不需要对这个字段使用索引。
	4. 避免对经常更新的表创建过多的索引：更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担
	5. 不建议用无序的值作为索引

根据应用的实际情况进行分析和判断，选择最合适的索引方式。

### (三) SQL语句
1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。
2. 【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。 说明：参见定义POJO类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。
3. 【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。 说明：配置映射关系，使字段与DO类解耦，方便维护。
4. 【强制】sql.xml配置参数使用：#{}，#param# **不要使用${} 此种方式容易出现SQL注入**。
5. 【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。 说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。
正例：
```
Map<String, Object> map = new HashMap<String, Object>();
map.put("start", start);
map.put("size", size);
```
6. 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。
7. 【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。
8. 【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。
9. 【参考】* *@Transactional事务不要滥用。事务会影响数据库的QPS **，另外使用事务的地方需要考虑各方面的回滚方案，包括**缓存回滚、搜索引擎回滚、消息补偿、统计修正**等。
10. 【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。
