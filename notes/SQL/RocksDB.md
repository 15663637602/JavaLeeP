# RocksDB是什么
 >高效发挥存储硬件性能的嵌入式**KV**存储引擎
 >>嵌入式 是指 将底层的存储封装好了，可以在它的上面搭建数据库服务
 >>> redis，mysql，mongo底层存储引擎都可以用它，如pika，myrocks
 # RocksDB解决了什么问题
>解决***写多读少***的问题，相对而言读的需求没那么旺盛，但是它读的性能也很好。 
>>有名的Mysql InnoDB B+树，主要是解决***读多写少***的问题
 # RocksDB是怎么解决写多读少的问题的
 >LSM-Tree
 >LSM-Tree不是数据结构，是磁盘中组织数据的一种方式
 
 ## 举个例子：
 * 通常我们的服务程序，在机器上面写日志为什么很快？--- **追加写**
     > 写日志是用**追加写**的方式来将数据写入到磁盘的，利用了磁盘的顺序IO，所以很快
     > **硬件访问速度**：
     > 内存顺序IO（如对数组的连续访问）100ns [远快于] 内存随机IO（如对树结构的访问）[约等于]     磁盘顺序IO [远快于] 磁盘随机IO 10ms
 
 * 依旧举B+树的例子，B+树是**就地写**，innoDB中某个数据是存储在某个**页**中，那么在对该数据做修改的时候，就必须通过数据结构的手段，找到该页，才能对它做修改。
 * 那么RocksDB呢，它则是**追加写**，不论之前磁盘中是否存在数据，都追加写。那么避免不了的就会产生**冗余数据**
    > 例如这三次操作过后，会追加写三条数据，第三次put不会覆盖第一次put：
    > Put(k1,v1)，Put(k2,v2)，Put(k1,v11)
 * 顺序写是很快了，但是查询就相对慢了，如何对查询做优化呢？
    > 可以将数据以**有序**数据块的方式存储，查找有序数组可以将复杂度 O(n) -> O(logN)
 * 冗余数据该如何处理呢？
    > 通过压缩合并的方式(merge)，清除冗余数据。
    > 但是压缩合并操作会阻塞查询和插入操作，那么就需要将：
    > 1. **将写的文件 拆分成多个小文件**，那么发生阻塞也阻塞一部分数据
    > 2. **在内存中做缓存**，类似于innoDB的 buffer pool，内存IO很快，所以可以用就地写(运用数据结构)，达到阈值后再将内存中的数据dump到磁盘。
    > 3. 数据查询时，先查询内存缓存的数据，缓存的数据是不存在冗余数据的。
    > 4. 如果内存中的数据还没有dump到磁盘，但是掉电了怎么办：**写内存之前先写到WAL**（类似于redo log）
 # LSM-Tree
https://pic2.zhimg.com/80/v2-37576525d52091fd713bb13556c92861_720w.webp
