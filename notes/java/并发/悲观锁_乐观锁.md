# 悲观锁
> 代表是 synchronized和Lock锁
1. 只有占有了线程的锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待。
2. 线程切换运行状态，会涉及线程的上下文切换，频繁发生会影响性能。
3. 实际上，线程在获取synchronized和Lock锁时，如果锁已被占用，都会做几次重试的操作，不会立马就切到阻塞状态。
# 乐观锁
> 代表是 AtomicInteger，使用cas保证原子性
1. **无需加锁**，就可以使得: 每次只有一个线程能成功的修改共享变量，**其他失败的线程**不需要停止(乐观精神)，**不断重试**直至成功。
2. 由于线程一直运行，不需要阻塞，就不涉及线程上下文切换。
3. **需要多核cpu支持**，且线程数不应超过cpu核数，因为失败线程想要不断重试的话，需要得到cpu才行。
