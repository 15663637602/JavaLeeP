## 语法层面
##### synchronized是关键字，源码在jvm中，用c++实现。
##### Lock是接口，有jdk提供，java实现。
##### 使用synchronized时，退出同步代码块会自动释放锁，而用Lock需要手动调用unlock方法。


## 功能层面
##### 二者都属于悲观锁，具备基本的互斥、同步、锁重入功能
- 互斥强调临界资源在同一时刻只能被一个进程访问，具有唯一性和排他性，但是不限制访问者对资源的访问顺序。
- 同步在互斥的基础上，限制了访问者的访问顺序，**强调不同访问者保持一定的逻辑顺序**访问临界资源。在大多数情况下，同步机制已经实现了互斥。
- 可重入锁就是当一个线程获得了某个对象的实例并进入一个方法A，这个线程在没有释放锁的情况下，能再次进入方法A。像**递归调用这个加锁方法**执行运算的时候，像synchronized和Reentrantlock都是可重入锁。Mutex（互斥锁）是不可重入锁。
- 公平锁，按照等待线程按照顺序排队，非公平锁，线程不按照先来后到排序。
##### Lock锁提供了很多synchronized不具备的功能
- Lock锁可以获取等待状态，获取哪些线程是阻塞的，或者是在等待的。
- Lock提供公平锁，当然非公平锁效率更高
- 支持可打断，可以设置超时时限，synchronized就只能死等。
- Lock支持多条件变量，多个等待队列。
##### Lock有适合不同场景的实现。
##### 性能层面
- 没有竞争的时候，synchronized做了很多优化，如偏向锁，轻量级锁，性能更好。
- 竞争激烈的时候，Lock的实现 性能偏好。
